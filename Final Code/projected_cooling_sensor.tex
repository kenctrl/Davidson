% This file was automatically created from the m-file 
% "m2tex.m" written by USL. 
% The fontencoding in this file is UTF-8. 
%  
% You will need to include the following two packages in 
% your LaTeX-Main-File. 
%  
% \usepackage{color} 
% \usepackage{fancyvrb} 
%  
% It is advised to use the following option for Inputenc 
% \usepackage[utf8]{inputenc} 
%  
  
% definition of matlab colors: 
\definecolor{mblue}{rgb}{0,0,1} 
\definecolor{mgreen}{rgb}{0.13333,0.5451,0.13333} 
\definecolor{mred}{rgb}{0.62745,0.12549,0.94118} 
\definecolor{mgrey}{rgb}{0.5,0.5,0.5} 
\definecolor{mdarkgrey}{rgb}{0.25,0.25,0.25} 
  
\DefineShortVerb[fontfamily=courier,fontseries=m]{\$} 
\DefineShortVerb[fontfamily=courier,fontseries=b]{\#} 
  
\noindent                                                                                                                          \hspace*{-1.6em}{\scriptsize 1}$  $\color{mblue}$function$\color{black}$ [first_initial_overlap,overlaps] = projected_cooling_sensor(L,D,$\color{mblue}$ ...$\color{black}$$\\ \hspace*{-1.6em}{\scriptsize 2}$      maxeig,nrepeat,H_obj)$\\ \hspace*{-1.6em}{\scriptsize 3}$  $\color{mgreen}#%% PROJECTED_COOLING_SENSOR performs the projected cooling sensor algorithm#\color{black}$$\\ \hspace*{-1.6em}{\scriptsize 4}$  $\color{mgreen}#%% multiple times on a DxD Hamiltonian over a lattice of size L. The outputs#\color{black}$$\\ \hspace*{-1.6em}{\scriptsize 5}$  $\color{mgreen}#%% are (1) the initial overlap with the randomized state and (2) the overlaps#\color{black}$$\\ \hspace*{-1.6em}{\scriptsize 6}$  $\color{mgreen}#%% after each iteration of the algorithm.#\color{black}$$\\ \hspace*{-1.6em}{\scriptsize 7}$      $\color{mgreen}$% L is the reservoir size.$\color{black}$$\\ \hspace*{-1.6em}{\scriptsize 8}$      $\color{mgreen}$% D is the dimension of the Hamiltonian.$\color{black}$$\\ \hspace*{-1.6em}{\scriptsize 9}$      $\color{mgreen}$% maxeig is the maximum energy eigenvalue.$\color{black}$$\\ \hspace*{-2em}{\scriptsize 10}$      $\color{mgreen}$% nrepeat is the number of iterations the algorithm is performed.$\color{black}$$\\ \hspace*{-2em}{\scriptsize 11}$      $\color{mgreen}$% H_obj is the Hamiltonian of interest. Set H_obj = 0 for arbitrary$\color{black}$$\\ \hspace*{-2em}{\scriptsize 12}$      $\color{mgreen}$% DxD Hamiltonians.$\color{black}$$\\ \hspace*{-2em}{\scriptsize 13}$  $\\ \hspace*{-2em}{\scriptsize 14}$  $\color{mgreen}#%% Set the run time proportional to L, and break each time step dt = 0.5 into#\color{black}$$\\ \hspace*{-2em}{\scriptsize 15}$  $\color{mgreen}#%% 10 subdivisions.#\color{black}$$\\ \hspace*{-2em}{\scriptsize 16}$  dt = 0.5;$\\ \hspace*{-2em}{\scriptsize 17}$  Lt = floor(L/dt*0.8);$\\ \hspace*{-2em}{\scriptsize 18}$  subdivisions = 10;$\\ \hspace*{-2em}{\scriptsize 19}$  $\\ \hspace*{-2em}{\scriptsize 20}$  $\color{mgreen}#%% Define the reservoir Hamiltonian H_res.#\color{black}$$\\ \hspace*{-2em}{\scriptsize 21}$  r = [0:L-1];$\\ \hspace*{-2em}{\scriptsize 22}$  H_res = - sparse(mod(r+1,L)+1,r+1,0.5) - sparse(mod(r-1,L)+1,r+1,0.5);$\\ \hspace*{-2em}{\scriptsize 23}$  $\\ \hspace*{-2em}{\scriptsize 24}$  $\color{mgreen}#%% Create arbitrary Hamiltonian if H_obj is not previously defined.#\color{black}$$\\ \hspace*{-2em}{\scriptsize 25}$  $\color{mblue}$if$\color{black}$ H_obj == 0$\\ \hspace*{-2em}{\scriptsize 26}$      H_obj = rand(D,D) + i*rand(D,D);$\\ \hspace*{-2em}{\scriptsize 27}$      H_obj = 0.5*(H_obj + H_obj');$\\ \hspace*{-2em}{\scriptsize 28}$  $\color{mblue}$end$\color{black}$$\\ \hspace*{-2em}{\scriptsize 29}$  $\\ \hspace*{-2em}{\scriptsize 30}$  $\color{mgreen}#%% Shift and scale H_obj so that the maximum energy of H_obj_new is maxeig.#\color{black}$$\\ \hspace*{-2em}{\scriptsize 31}$  list = sort(eig(H_obj));$\\ \hspace*{-2em}{\scriptsize 32}$  H_object_new = H_obj-(list(1)+list(2))/2*eye(D);$\\ \hspace*{-2em}{\scriptsize 33}$  scale = max(eig(H_object_new));$\\ \hspace*{-2em}{\scriptsize 34}$  H_object_new = H_object_new/scale*maxeig;$\\ \hspace*{-2em}{\scriptsize 35}$  $\\ \hspace*{-2em}{\scriptsize 36}$  $\color{mgreen}#%% Define system Hamiltonian H as the tensor product between H_res and H_obj_new.#\color{black}$$\\ \hspace*{-2em}{\scriptsize 37}$  H = sparse(D*L,D*L);$\\ \hspace*{-2em}{\scriptsize 38}$  $\color{mblue}$for$\color{black}$ ii = 0:D-1 $\\ \hspace*{-2em}{\scriptsize 39}$      H(ii*L+[0:L-1]+1,ii*L+[0:L-1]+1) = H_res;$\\ \hspace*{-2em}{\scriptsize 40}$  $\color{mblue}$end$\color{black}$$\\ \hspace*{-2em}{\scriptsize 41}$  $\color{mblue}$for$\color{black}$ jj = 0:D-1$\\ \hspace*{-2em}{\scriptsize 42}$      $\color{mblue}$for$\color{black}$ ii = 0:D-1$\\ \hspace*{-2em}{\scriptsize 43}$          H(ii*L+1,jj*L+1) = H(ii*L+1,jj*L+1) + H_object_new(ii+1,jj+1)/2.0;$\\ \hspace*{-2em}{\scriptsize 44}$          H(ii*L+2,jj*L+1) = H(ii*L+2,jj*L+1) + H_object_new(ii+1,jj+1)/2.0;$\\ \hspace*{-2em}{\scriptsize 45}$          H(ii*L+1,jj*L+2) = H(ii*L+1,jj*L+2) + H_object_new(ii+1,jj+1)/2.0;$\\ \hspace*{-2em}{\scriptsize 46}$          H(ii*L+2,jj*L+2) = H(ii*L+2,jj*L+2) + H_object_new(ii+1,jj+1)/2.0;$\\ \hspace*{-2em}{\scriptsize 47}$      $\color{mblue}$end$\color{black}$$\\ \hspace*{-2em}{\scriptsize 48}$  $\color{mblue}$end$\color{black}$$\\ \hspace*{-2em}{\scriptsize 49}$  $\\ \hspace*{-2em}{\scriptsize 50}$  $\color{mgreen}#%% Calculate the exact ground state to check for overlap later.#\color{black}$$\\ \hspace*{-2em}{\scriptsize 51}$  [vv,dd] = eig(H_obj);$\\ \hspace*{-2em}{\scriptsize 52}$  [~,ord] = sort(diag(dd));$\\ \hspace*{-2em}{\scriptsize 53}$  index = find(abs(vv(:,ord(1))) == max(abs(vv(:,ord(1)))));$\\ \hspace*{-2em}{\scriptsize 54}$  vv_exact = vv(:,ord(1))/vv(index,ord(1));$\\ \hspace*{-2em}{\scriptsize 55}$  $\\ \hspace*{-2em}{\scriptsize 56}$  $\color{mgreen}#%% Define the random values of the initial state.#\color{black}$$\\ \hspace*{-2em}{\scriptsize 57}$  vobj_init = zeros(D,1);$\\ \hspace*{-2em}{\scriptsize 58}$  $\color{mblue}$for$\color{black}$ ii = 0:D-1$\\ \hspace*{-2em}{\scriptsize 59}$      vobj_init(ii+1) = (rand-0.5) + i*(rand-0.5);$\\ \hspace*{-2em}{\scriptsize 60}$  $\color{mblue}$end$\color{black}$$\\ \hspace*{-2em}{\scriptsize 61}$  v_init = zeros(D*L,1);$\\ \hspace*{-2em}{\scriptsize 62}$  $\\ \hspace*{-2em}{\scriptsize 63}$  $\color{mgreen}#%% Perform the projected cooling sensor algorithm nrepeat times.#\color{black}$$\\ \hspace*{-2em}{\scriptsize 64}$  $\color{mblue}$for$\color{black}$ ntrial = 1:nrepeat$\\ \hspace*{-2em}{\scriptsize 65}$  $\\ \hspace*{-2em}{\scriptsize 66}$      $\color{mgreen}$%Define initial state v_init using random values from vobj_init.$\color{black}$$\\ \hspace*{-2em}{\scriptsize 67}$      $\color{mblue}$for$\color{black}$ ii = 0:D-1$\\ \hspace*{-2em}{\scriptsize 68}$          v_init(ii*L+1) = vobj_init(ii+1,1);$\\ \hspace*{-2em}{\scriptsize 69}$          v_init(ii*L+2) = vobj_init(ii+1,1);       $\\ \hspace*{-2em}{\scriptsize 70}$      $\color{mblue}$end$\color{black}$$\\ \hspace*{-2em}{\scriptsize 71}$      $\\ \hspace*{-2em}{\scriptsize 72}$      $\color{mgreen}$%Perform time evolution for first time step dt.$\color{black}$$\\ \hspace*{-2em}{\scriptsize 73}$      psi1(:,1) = exponentiate(v_init,H,-i*dt,subdivisions);    $\\ \hspace*{-2em}{\scriptsize 74}$  $\\ \hspace*{-2em}{\scriptsize 75}$      $\color{mgreen}$%Perform time evolution for remaining time steps.$\color{black}$$\\ \hspace*{-2em}{\scriptsize 76}$      $\color{mblue}$for$\color{black}$ nt = 1:Lt$\\ \hspace*{-2em}{\scriptsize 77}$          psi1(:,nt+1) = exponentiate(psi1(:,nt),H,-i*dt,subdivisions);$\\ \hspace*{-2em}{\scriptsize 78}$      $\color{mblue}$end$\color{black}$$\\ \hspace*{-2em}{\scriptsize 79}$  $\\ \hspace*{-2em}{\scriptsize 80}$      $\color{mgreen}$%Graph the convergence of the state(s) vs. time.$\color{black}$$\\ \hspace*{-2em}{\scriptsize 81}$      figure(ntrial)$\\ \hspace*{-2em}{\scriptsize 82}$      hold $\color{mred}$on$\color{black}$$\\ \hspace*{-2em}{\scriptsize 83}$      $\color{mblue}$for$\color{black}$ ii = 0:D-1$\\ \hspace*{-2em}{\scriptsize 84}$          plot(dt*[1:Lt],log(abs(psi1(ii*L+1,1:Lt)+psi1(ii*L+2,1:Lt)).^2))$\\ \hspace*{-2em}{\scriptsize 85}$      $\color{mblue}$end$\color{black}$$\\ \hspace*{-2em}{\scriptsize 86}$      xlabel($\color{mred}$'{\it t}'$\color{black}$,$\color{mred}$'FontSize'$\color{black}$,14)$\\ \hspace*{-2em}{\scriptsize 87}$      ylabel($\color{mred}$'ln({\it|v_{PCS} |^2})'$\color{black}$,$\color{mred}$'FontSize'$\color{black}$,14)$\\ \hspace*{-2em}{\scriptsize 88}$      hold $\color{mred}$off$\color{black}$$\\ \hspace*{-2em}{\scriptsize 89}$   $\\ \hspace*{-2em}{\scriptsize 90}$      $\color{mgreen}$%Find the reconstructed ground state and display with trial number.$\color{black}$$\\ \hspace*{-2em}{\scriptsize 91}$      v_PC = zeros(D,1);$\\ \hspace*{-2em}{\scriptsize 92}$      $\color{mblue}$for$\color{black}$ ii = 0:D-1$\\ \hspace*{-2em}{\scriptsize 93}$          v_PC(ii+1,1) = psi1(ii*L+1,Lt) + psi1(ii*L+2,Lt);$\\ \hspace*{-2em}{\scriptsize 94}$      $\color{mblue}$end$\color{black}$$\\ \hspace*{-2em}{\scriptsize 95}$      index = find(abs(v_PC) == max(abs(v_PC)));$\\ \hspace*{-2em}{\scriptsize 96}$      v_PC = v_PC/v_PC(index);$\\ \hspace*{-2em}{\scriptsize 97}$      disp(ntrial)$\\ \hspace*{-2em}{\scriptsize 98}$      disp([v_PC $\color{mred}$vv_exact])$\color{black}$$\\ \hspace*{-2em}{\scriptsize 99}$      $\\ \hspace*{-2.4em}{\scriptsize 100}$      $\color{mgreen}$%Calculate initial and final overlap values and display for each trial.$\color{black}$$\\ \hspace*{-2.4em}{\scriptsize 101}$      initial_overlap(ntrial,1) = (abs(vv_exact'*vobj_init))^2$\color{mblue}$ ...$\color{black}$$\\ \hspace*{-2.4em}{\scriptsize 102}$          /((vv_exact'*vv_exact)*(vobj_init'*vobj_init));$\\ \hspace*{-2.4em}{\scriptsize 103}$      final_overlap(ntrial,1) = (abs(v_PC'*vv_exact))^2$\color{mblue}$ ...$\color{black}$$\\ \hspace*{-2.4em}{\scriptsize 104}$          /((vv_exact'*vv_exact)*(v_PC'*v_PC));$\\ \hspace*{-2.4em}{\scriptsize 105}$      disp(initial_overlap(ntrial,1))$\\ \hspace*{-2.4em}{\scriptsize 106}$      disp(final_overlap(ntrial,1))$\\ \hspace*{-2.4em}{\scriptsize 107}$      $\\ \hspace*{-2.4em}{\scriptsize 108}$      $\color{mgreen}$%Set initial state as reconstructed state for next iteration.$\color{black}$$\\ \hspace*{-2.4em}{\scriptsize 109}$      vobj_init = v_PC;$\\ \hspace*{-2.4em}{\scriptsize 110}$  $\color{mblue}$end$\color{black}$$\\ \hspace*{-2.4em}{\scriptsize 111}$  $\\ \hspace*{-2.4em}{\scriptsize 112}$  $\color{mgreen}#%% Define initial overlap for algorithm and final overlaps for each ntrial.#\color{black}$$\\ \hspace*{-2.4em}{\scriptsize 113}$  first_initial_overlap = initial_overlap(1);$\\ \hspace*{-2.4em}{\scriptsize 114}$  overlaps = final_overlap;$\\ \hspace*{-2.4em}{\scriptsize 115}$  $\\ \hspace*{-2.4em}{\scriptsize 116}$  $\color{mgreen}#%% Graph log error of overlap vs. iteration.#\color{black}$$\\ \hspace*{-2.4em}{\scriptsize 117}$  figure(nrepeat+1)$\\ \hspace*{-2.4em}{\scriptsize 118}$  plot(log(1-final_overlap))$\\ \hspace*{-2.4em}{\scriptsize 119}$  xlabel($\color{mred}$'Iteration'$\color{black}$,$\color{mred}$'FontSize'$\color{black}$,14)$\\ \hspace*{-2.4em}{\scriptsize 120}$  ylabel($\color{mred}$'ln(1-{\it O})'$\color{black}$,$\color{mred}$'FontSize'$\color{black}$,14)$\\ \hspace*{-2.4em}{\scriptsize 121}$  $\color{mblue}$end$\color{black}$$\\ 
  
\UndefineShortVerb{\$} 
\UndefineShortVerb{\#}